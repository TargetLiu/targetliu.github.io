<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">
  <channel>
    <title>TargetLiu</title>
    <link>http://127.0.0.1:9899</link>
    <description>TargetLiu - 吃土的码农</description>
    <managingEditor>os@targetliu.com (TargetLiu)</managingEditor>
    <pubDate>Thu, 13 Oct 2016 21:48:49 +0800</pubDate>
    <item>
      <title>开源一个Golang写的Excel(xlsx)导入MySQL小工具</title>
      <link>http://http://targetliu.com/2016/9/16/golang-excel-xlsx-to-mysql.html</link>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这是工作中用到的一个小工具，将Excel(xlsx)表导入MySQL表中，用Golang写的，每条记录单独一条 &lt;code&gt;goroutine&lt;/code&gt; 处理，提高效率。支持随机数生成、密码生成、时间戳；支持关联查询、附表操作等。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;使用方法&#34;&gt;使用方法&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;使用Go编译安装或直接下载：&lt;a href=&#34;https://github.com/TargetLiu/xlsxtomysql/releases&#34;&gt;https://github.com/TargetLiu/xlsxtomysql/releases&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;使用命令： &lt;code&gt;xlsxtomysql [DSN] [数据表名称] [*.xlsx]&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;dsn&#34;&gt;DSN&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;格式：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;[username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;amp;...&amp;amp;paramN=valueN]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;示例：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;root:123@tcp(127.0.0.1:3306)/dbname&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意：&#xA;Linux、Mac下可能需要输入 &lt;code&gt;\( \)&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;excel表导入结构说明&#34;&gt;Excel表导入结构说明&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;只支持单Sheet&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;第一行对应数据库表字段&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;通过 &lt;code&gt;|&lt;/code&gt; 分割&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;字段名|unique&lt;/code&gt; 判断重复，重复的自动跳过&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;字段名|password|[md5|bcrypt]&lt;/code&gt; 密码生成，第二个参数[md5|bcrypt]&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;字段名|find|表名|需要获取的字段|查询字段&lt;/code&gt; 根据内容从其它表查询并获取字段，格式 &lt;code&gt;SELECT 需要获取的字段 FROM 表名 WHERE 查询字段 = 内容&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;:other&lt;/code&gt; 附表操作&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;内容行&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;:random&lt;/code&gt; 生成随机字符串&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;:time&lt;/code&gt; 当前unix时间戳&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;:null&lt;/code&gt;  空值，自动跳过该值，一般可用于自增id&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;如果该列为 &lt;code&gt;password&lt;/code&gt; ，内容为[明文密码]或[明文密码|盐]，盐可以通过[:字段名]获取之前的字段名。密码将自动根据字段名中填写的加密方式进行加密&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;如果该列为 &lt;code&gt;other&lt;/code&gt; , 格式[表名|字段1|字段2|字段3&amp;hellip;.] 其它表需要按顺序为每个字段添加内容。字段可以为[:null|:id(主表生成的自增ID)|:random|:time]&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2 id=&#34;excel截图&#34;&gt;Excel截图&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/TargetLiu/xlsxtomysql/raw/master/screenshot.jpg&#34; alt=&#34;Excel截图&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;github&#34;&gt;GitHub&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/TargetLiu/xlsxtomysql&#34;&gt;https://github.com/TargetLiu/xlsxtomysql&lt;/a&gt;&lt;/p&gt;&#xA;</description>
      <author>TargetLiu</author>
      <pubDate>Fri, 16 Sep 2016 15:37:41 +0000</pubDate>
    </item>
    <item>
      <title>Golang学习笔记 - 标准库&#39;net/http&#39;的简析及自制简单路由框架</title>
      <link>http://http://targetliu.com/2016/8/18/golang-http-router.html</link>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;还是在继续学习Go的路上，曾经在使用PHP的时候吃过过度依赖框架的亏。现在学习Go的时候决定先打好基础，从标准库学起走。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2 id=&#34;源码分析&#34;&gt;源码分析&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;我们知道最简单的建立http服务器代码基本上都是这样的：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;http.HandleFunc(&#39;/&#39;, func(w http.ResponseWriter, r *http.Request){&#xA;    fmt.Fprint(w, &amp;quot;Hello world&amp;quot;)&#xA;})&#xA;http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样就成功的建立了一个监听 &lt;code&gt;8080&lt;/code&gt; 端口的http服务器，当访问的时候输出 &lt;code&gt;Hello world&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们顺藤摸瓜来看看 &lt;code&gt;HandleFunc&lt;/code&gt; 做了些什么事：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {&#xA;    DefaultServeMux.HandleFunc(pattern, handler)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;p&gt;这里继续通过调用 &lt;code&gt;DefaultServeMux&lt;/code&gt; 的 &lt;code&gt;HandleFunc&lt;/code&gt; 方法注册路由，这个 &lt;code&gt;DefaultServeMux&lt;/code&gt; 又是何方圣神：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ServeMux struct {&#xA;    mu    sync.RWMutex&#xA;    m     map[string]muxEntry&#xA;    hosts bool // whether any patterns contain hostnames&#xA;}&#xA;&#xA;type muxEntry struct {&#xA;    explicit bool&#xA;    h        Handler&#xA;    pattern  string&#xA;}&#xA;&#xA;// NewServeMux allocates and returns a new ServeMux.&#xA;func NewServeMux() *ServeMux { return new(ServeMux) }&#xA;&#xA;// DefaultServeMux is the default ServeMux used by Serve.&#xA;var DefaultServeMux = &amp;amp;defaultServeMux&#xA;&#xA;var defaultServeMux ServeMux&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;DefaultServeMux&lt;/code&gt; 是 &lt;code&gt;net/http&lt;/code&gt; 包提供的一个默认的 &lt;code&gt;ServeMux&lt;/code&gt; 类型，&lt;code&gt;ServeMux&lt;/code&gt; 实现了 &lt;code&gt;Handler&lt;/code&gt; 接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;追根究底，发现http服务器收到一条请求后通过 &lt;code&gt;go c.serve(ctx)&lt;/code&gt; 开启&lt;code&gt;goroutine&lt;/code&gt; 处理这个请求，在这个过程中调用了 &lt;code&gt;Handler&lt;/code&gt; 接口函数 &lt;code&gt;ServeHTTP&lt;/code&gt; 来做进一步的处理（比如匹配方法、链接等等）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以，我们就可以理解 &lt;code&gt;ServeMux&lt;/code&gt; 就是 &lt;code&gt;net/http&lt;/code&gt; 一个内置的路由功能。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;继续回到 &lt;code&gt;HandleFunc&lt;/code&gt; 来：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {&#xA;    mux.Handle(pattern, HandlerFunc(handler))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;ServeMux&lt;/code&gt; 的 &lt;code&gt;HandleFunc&lt;/code&gt; 方法将我们传入的路由具体实现函数转换成 &lt;code&gt;HandlerFunc&lt;/code&gt; 类型并通过 &lt;code&gt;Handle&lt;/code&gt; 注册到路由。这个 &lt;code&gt;HandlerFunc&lt;/code&gt; 类型也实现了 &lt;code&gt;Handler&lt;/code&gt; 接口：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type HandlerFunc func(ResponseWriter, *Request)&#xA;&#xA;// ServeHTTP calls f(w, r).&#xA;func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {&#xA;    f(w, r)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后到了 &lt;code&gt;Handle&lt;/code&gt; 这个方法， &lt;code&gt;Handle&lt;/code&gt; 方法通过将 &lt;code&gt;pattern&lt;/code&gt; 路径以及实现了 &lt;code&gt;Handler&lt;/code&gt; 接口的方法一一对应的保存到 &lt;code&gt;ServeMux&lt;/code&gt; 的 &lt;code&gt;map[string]muxEntry&lt;/code&gt; 中，方便后续请求的时候调用。因此，也可以通过 &lt;code&gt;Handle&lt;/code&gt; 直接传入一个实现了 &lt;code&gt;Handler&lt;/code&gt; 接口的方法注册路由。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;至此，&lt;code&gt;net/http&lt;/code&gt; 包中默认路由的注册过程基本上已经走完。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;至于请求的时候路由调用，记住通过 &lt;code&gt;ServeHTTP&lt;/code&gt; 查找 &lt;code&gt;map&lt;/code&gt; 中对应路径并调用相关方法就行了。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;自制路由&#34;&gt;自制路由&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;通过以上的分析，我们可以依样画葫芦，实现自己的路由功能。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package route&#xA;&#xA;import (&#xA;    &amp;quot;net/http&amp;quot;&#xA;    &amp;quot;strings&amp;quot;&#xA;)&#xA;&#xA;//返回一个Router实例&#xA;func NewRouter() *Router {&#xA;    return new(Router)&#xA;}&#xA;&#xA;//路由结构体，包含一个记录方法、路径的map&#xA;type Router struct {&#xA;    Route map[string]map[string]http.HandlerFunc&#xA;}&#xA;&#xA;//实现Handler接口，匹配方法以及路径&#xA;func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {&#xA;    if h, ok := r.Route[req.Method][req.URL.String()]; ok {&#xA;        h(w, req)&#xA;    }&#xA;}&#xA;&#xA;//根据方法、路径将方法注册到路由&#xA;func (r *Router) HandleFunc(method, path string, f http.HandlerFunc) {&#xA;    method = strings.ToUpper(method)&#xA;    if r.Route == nil {&#xA;        r.Route = make(map[string]map[string]http.HandlerFunc)&#xA;    }&#xA;    if r.Route[method] == nil {&#xA;        r.Route[method] = make(map[string]http.HandlerFunc)&#xA;    }&#xA;    r.Route[method][path] = f&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r := route.NewRouter()&#xA;r.HandleFunc(&amp;quot;GET&amp;quot;, &amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) {&#xA;    fmt.Fprint(w, &amp;quot;Hello Get!&amp;quot;)&#xA;})&#xA;r.HandleFunc(&amp;quot;POST&amp;quot;, &amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) {&#xA;    fmt.Fprint(w, &amp;quot;hello POST!&amp;quot;)&#xA;})&#xA;http.ListenAndServe(&amp;quot;:8080&amp;quot;, r)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这个例子只是依样画葫芦的简单功能实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一个完整的路由框架应该包含更复杂的匹配、错误检测等等功能，大家可以试着自己动手试试。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;阅读源码和重复造轮子都是学习的方法。&lt;/p&gt;&#xA;</description>
      <author>TargetLiu</author>
      <pubDate>Thu, 18 Aug 2016 15:36:23 +0000</pubDate>
    </item>
    <item>
      <title>Go写的简单TCP聊天室示例</title>
      <link>http://http://targetliu.com/2016/8/3/golang-tcp-chat-room.html</link>
      <description>&lt;p&gt;最近学习GO，写了一个聊天室来加深对 &lt;code&gt;net&lt;/code&gt; 包和多线程的理解。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;期间也遇到了一些小问题，比如 &lt;code&gt;scan&lt;/code&gt; 如何读取一整行（包括空格）等。总的来说个人感觉 &lt;code&gt;Go&lt;/code&gt; 还是一门很年轻的语言，资料、技巧上面还需要时间的积累。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过，我已入坑&amp;hellip;..&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;github&#34;&gt;GitHub&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/TargetLiu/golang-chat&#34;&gt;GitHub地址&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一个简单的基于GO语言的聊天室示例，参考了网上许多类似代码。代码有简单注释。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;单执行文件，通过命令的方式选择启动服务端监听还是客户端连接。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;功能：客户端昵称、服务端消息、服务端踢人命令。&lt;/p&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;使用方法&#34;&gt;使用方法&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;克隆代码&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/TargetLiu/chat&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;编译安装&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code&gt;go build&#xA;go install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;运行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code&gt;//服务端&#xA;chat server [:端口号]&#xA;//客户端&#xA;chat client [服务端IP地址:端口号] &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;服务端命令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code&gt;//发送消息直接输入即可&#xA;//踢人&#xA;kick|[客户端昵称]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
      <author>TargetLiu</author>
      <pubDate>Wed, 03 Aug 2016 15:34:50 +0000</pubDate>
    </item>
    <item>
      <title>VSCODE中godef无法跳转到定义的问题</title>
      <link>http://http://targetliu.com/2016/8/2/vscode-can-not-go-to-def.html</link>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;之前研究GOLANG时一直用LiteIDE，不得不说，LiteIDE的确不错，但是总感觉缺乏美感，是一款很中规中矩的编辑器。网上看到大家对VSCODE评价不错，尝试后发现的确不错，布局简洁、插件化、支持中文，通过VSCODE GO扩展能够很舒服的写GO的代码。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;不过在实际使用过程中发现 &lt;code&gt;net&lt;/code&gt; 包无法正常跳转到定义，如下段代码 &lt;code&gt;ResolveTCPAddr&lt;/code&gt;就无法正常跳转&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;net&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    _, err := net.ResolveTCPAddr(&amp;quot;tcp&amp;quot;, &amp;quot;:4040&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;p&gt;由于VSCODE GO中跳转到定义使用的是godef，遂通过godef的debug模式查看问题原因：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;godef -debug -f main.go net.ResolveTCPAddr&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;运行结果如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;2016/08/02 01:17:30 exprType tuple:false pkg: *ast.SelectorExpr net.ListenTCP [&#xA;2016/08/02 01:17:30 exprType tuple:false pkg: *ast.Ident net [&#xA;2016/08/02 01:17:30 exprType tuple:false pkg: *ast.ImportSpec &amp;quot;net&amp;quot; [&#xA;2016/08/02 01:17:30 ] -&amp;gt; 0x0, Type{package &amp;quot;&amp;quot; *ast.ImportSpec &amp;quot;net&amp;quot;}&#xA;2016/08/02 01:17:30 ] -&amp;gt; 0xc820157860, Type{package &amp;quot;&amp;quot; *ast.ImportSpec &amp;quot;net&amp;quot;}&#xA;2016/08/02 01:17:30 member Type{package &amp;quot;&amp;quot; *ast.ImportSpec &amp;quot;net&amp;quot;} &#39;ListenTCP&#39; {&#xA;2016/08/02 01:17:30     /usr/local/go/src/net/cgo_android.go:10:8: cannot find identifier for package &amp;quot;C&amp;quot;: cannot find package &amp;quot;C&amp;quot; in any of:&#xA;    /usr/local/go/src/vendor/C (vendor tree)&#xA;    /usr/local/go/src/C (from $GOROOT)&#xA;    /Users/targetliu/dev/govendor/src/C (from $GOPATH)&#xA;    /Users/targetliu/dev/golang/src/C&#xA;2016/08/02 01:17:30 } -&amp;gt; &amp;lt;nil&amp;gt;&#xA;2016/08/02 01:17:30 ] -&amp;gt; 0x0, Type{bad &amp;quot;&amp;quot; &amp;lt;nil&amp;gt; }&#xA;2016/08/02 01:17:30 exprType tuple:false pkg: *ast.SelectorExpr net.ListenTCP [&#xA;2016/08/02 01:17:30 exprType tuple:false pkg: *ast.Ident net [&#xA;2016/08/02 01:17:30 exprType tuple:false pkg: *ast.ImportSpec &amp;quot;net&amp;quot; [&#xA;2016/08/02 01:17:30 ] -&amp;gt; 0x0, Type{package &amp;quot;&amp;quot; *ast.ImportSpec &amp;quot;net&amp;quot;}&#xA;2016/08/02 01:17:30 ] -&amp;gt; 0xc820157860, Type{package &amp;quot;&amp;quot; *ast.ImportSpec &amp;quot;net&amp;quot;}&#xA;2016/08/02 01:17:30 member Type{package &amp;quot;&amp;quot; *ast.ImportSpec &amp;quot;net&amp;quot;} &#39;ListenTCP&#39; {&#xA;2016/08/02 01:17:30     /usr/local/go/src/net/cgo_android.go:10:8: cannot find identifier for package &amp;quot;C&amp;quot;: cannot find package &amp;quot;C&amp;quot; in any of:&#xA;    /usr/local/go/src/vendor/C (vendor tree)&#xA;    /usr/local/go/src/C (from $GOROOT)&#xA;    /Users/targetliu/dev/govendor/src/C (from $GOPATH)&#xA;    /Users/targetliu/dev/golang/src/C&#xA;2016/08/02 01:17:30 } -&amp;gt; &amp;lt;nil&amp;gt;&#xA;2016/08/02 01:17:30 ] -&amp;gt; 0x0, Type{bad &amp;quot;&amp;quot; &amp;lt;nil&amp;gt; }&#xA;godef: no declaration found for net.ListenTCP&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意到这一句:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;cannot find identifier for package &amp;quot;C&amp;quot;: cannot find package &amp;quot;C&amp;quot; in any of:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;原来是 &lt;code&gt;net&lt;/code&gt; 包里 &lt;code&gt;import C&lt;/code&gt; ，然而C并不是一个具体真实存在的包，所以godef无法进行分析，导致找不到定义。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;godef的GitHub上作者也发现了同样的问题：&lt;a href=&#34;https://github.com/rogpeppe/godef/issues/41&#34;&gt;Issue:net.LookupIP fails #41&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在godef的GitHub上看到有人提交了针对这个问题的解决方案：&lt;a href=&#34;https://github.com/rogpeppe/godef/pull/44&#34;&gt;[master] Special treatment for &amp;ldquo;C&amp;rdquo; package. #44&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据这个提交，可以尝试使用如下方法解决：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;找到并打开godef的 &lt;code&gt;go/parser/parser.go&lt;/code&gt; 这个文件&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;在 &lt;code&gt;1970行&lt;/code&gt; 左右添加(代码中+号部分，可以通过搜索定位)：&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code&gt;if declIdent == nil {&#xA;              filename := p.fset.Position(path.Pos()).Filename&#xA;              name, err := p.pathToName(litToString(path), filepath.Dir(filename))&#xA; +            if litToString(path) == &amp;quot;C&amp;quot; {&#xA; +                name = &amp;quot;C&amp;quot;&#xA; +            }&#xA;              if name == &amp;quot;&amp;quot; {&#xA;                  p.error(path.Pos(), fmt.Sprintf(&amp;quot;cannot find identifier for package %q: %v&amp;quot;, litToString(path), err))&#xA;              } else {&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重新编译godef&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;如果遇到同样问题的同学不妨试一试以上方式，至少对于我来说，问题得到了解决。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也希望作者能尽快修复这个问题。&lt;/p&gt;&#xA;</description>
      <author>TargetLiu</author>
      <pubDate>Tue, 02 Aug 2016 15:33:27 +0000</pubDate>
    </item>
    <item>
      <title>Golang - iris中通过Plugin设置http超时时间（更新：作者已经提供相关设置）</title>
      <link>http://http://targetliu.com/2016/7/29/golang-iris-http-timeout.html</link>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kataras/iris&#34;&gt;kataras/iris&lt;/a&gt;是一款基于&lt;a href=&#34;https://github.com/valyala/fasthttp&#34;&gt;valyala/fasthttp&lt;/a&gt;的web开发框架。注重效率，在&lt;a href=&#34;https://github.com/smallnest/go-web-framework-benchmark&#34;&gt;Benchmarks&lt;/a&gt;对比中也表现出了速度的优势。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2 id=&#34;更新作者提供的相关设置选项&#34;&gt;更新作者提供的相关设置选项&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;根据留言和 &lt;code&gt;iris&lt;/code&gt; 最新的&lt;a href=&#34;https://github.com/kataras/iris/commit/3c50d26808461e8f28b66e99bb6511a875e8cfb5&#34;&gt;提交(3c50d26)&lt;/a&gt;，现在只需要使用ListenTo并且配置相关选项既可以设置超时时间（需要 &lt;code&gt;go get -u&lt;/code&gt; 升级 &lt;code&gt;iris&lt;/code&gt; 到最新版本）：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;iris.ListenTo(config.Server{WriteTimeout: 5* time.Second, ReadTimeout=&#xA;5*time.Second, ListeningAddr:&amp;quot;:8080&amp;quot;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;通过plugin设置超时时间&#34;&gt;通过Plugin设置超时时间&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;最近学习GOLANG时阅读到&lt;a href=&#34;http://colobu.com/2016/07/01/the-complete-guide-to-golang-net-http-timeouts/&#34;&gt;Go net/http 超时机制完全手册&lt;/a&gt;，GO自带的 &lt;code&gt;net/http&lt;/code&gt; 中可以使用&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;srv := &amp;amp;http.Server{  &#xA;    ReadTimeout: 5 * time.Second,&#xA;    WriteTimeout: 10 * time.Second,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;来设置超时时间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同样的，在 &lt;code&gt;valyala/fasthttp&lt;/code&gt; 中也可以使用&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;srv := &amp;amp;fasthttp.Server{  &#xA;    ReadTimeout: 5 * time.Second,&#xA;    WriteTimeout: 10 * time.Second,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;进行设置。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过在iris中，虽然 &lt;code&gt;iris.Server&lt;/code&gt; 是嵌入了 &lt;code&gt;fasthttp.Server&lt;/code&gt; 不过iris在 &lt;code&gt;Listen&lt;/code&gt; 之前是没有创建的，没法设置超时时间。&#xA;阅读iris文档和代码后发现，为给iris中的 &lt;code&gt;fasthttp.Server&lt;/code&gt; 也设置超时时间，可以通过 &lt;a href=&#34;https://kataras.gitbooks.io/iris/content/plugins.html&#34;&gt;iris Plugins&lt;/a&gt; 机制进行设置。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;iris的Plugins类似于钩子、事物监听、中间件，可以在特定的情况下触发事件。我们只用在Listen之前设置超时即可达到目的了。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;app.Plugins.PreListen(func(s *iris.Framework) {&#xA;    s.Servers.Main().ReadTimeout = 5 * time.Second&#xA;    s.Servers.Main().WriteTimeout = 5 * time.Second&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;同理，在其它无论是基于 &lt;code&gt;net/http&lt;/code&gt; 还是 &lt;code&gt;valyala/fasthttp&lt;/code&gt; 的框架中都可以看看Server具体是在什么时候创建以及有没有可能通过在Listen之前触发的事件来设置超时时间。&lt;/p&gt;&#xA;</description>
      <author>TargetLiu</author>
      <pubDate>Fri, 29 Jul 2016 15:32:01 +0000</pubDate>
    </item>
    <item>
      <title>Lumen中注册使用Artisan Console</title>
      <link>http://http://targetliu.com/2016/7/22/lumen-artisan-console.html</link>
      <description>&lt;p&gt;Laravel中使用 &lt;code&gt;Artisan Console&lt;/code&gt; 有详细的介绍。&lt;a href=&#34;https://laravel.com/docs/5.2/artisan&#34;&gt;Laravel Artisan Console 官方文档&lt;/a&gt;，除了创建和注册 &lt;code&gt;Artisan Console&lt;/code&gt; 与Lumen稍许不同外，其它内容基本都一样。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是实际项目中，我更希望用Lumen的 &lt;code&gt;Artisan Console&lt;/code&gt; 来执行一些简单的数据迁移、版本升级等操作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面就以&lt;a href=&#34;https://laravel.com/docs/5.2/artisan&#34;&gt;官方文档&lt;/a&gt;中的示例来简单说一下Lumen中怎么注册使用 &lt;code&gt;Artisan Console&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h1 id=&#34;创建-artisan-console-命令文件&#34;&gt;创建 &lt;code&gt;Artisan Console&lt;/code&gt;命令文件&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Lumen创建命令只能通过手动创建文件。&#xA;在 &lt;code&gt;app/Console/Commands&lt;/code&gt; 创建 &lt;code&gt;SendEmails&lt;/code&gt; 用来编写命令：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;namespace App\Console\Commands;&#xA;&#xA;use App\User;&#xA;use App\DripEmailer;&#xA;use Illuminate\Console\Command;&#xA;&#xA;class SendEmails extends Command{&#xA;    /**&#xA;     * 控制台命令名称&#xA;     *&#xA;     * @var string&#xA;     */&#xA;    protected $signature = &#39;email:send {user}&#39;;&#xA;&#xA;    /**&#xA;     * 控制台命令描述&#xA;     *&#xA;     * @var string&#xA;     */&#xA;    protected $description = &#39;Send drip e-mails to a user&#39;;&#xA;&#xA;    /**&#xA;     * The drip e-mail service.&#xA;     *&#xA;     * @var DripEmailer&#xA;     */&#xA;    protected $drip;&#xA;&#xA;    /**&#xA;     * 创建新的命令实例&#xA;     *&#xA;     * @param  DripEmailer  $drip&#xA;     * @return void&#xA;     */&#xA;    public function __construct(DripEmailer $drip)&#xA;    {&#xA;        parent::__construct();&#xA;        $this-&amp;gt;drip = $drip;&#xA;    }&#xA;&#xA;    /**&#xA;     * 执行控制台命令&#xA;     *&#xA;     * @return mixed&#xA;     */&#xA;    public function handle()&#xA;    {&#xA;        $this-&amp;gt;drip-&amp;gt;send(User::find($this-&amp;gt;argument(&#39;user&#39;)));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;命令编写具体方法请查看Laravel的&lt;a href=&#34;https://laravel.com/docs/5.2/artisan&#34;&gt;官方文档&lt;/a&gt; ，Lumen是一样的。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;注册命令&#34;&gt;注册命令&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Lumen与Laravel最主要的差异就在这里，Lumen需要自己写服务提供者来注册命令。&#xA;在 &lt;code&gt;app/Providers&lt;/code&gt; 里创建一个新的服务提供者：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;namespace App\Providers;&#xA;&#xA;use Illuminate\Support\ServiceProvider;&#xA;use App\Console\Commands\SendEmails;&#xA;&#xA;class SendEmailsServiceProvider extends ServiceProvider&#xA;{&#xA;    /**&#xA;     * Indicates if loading of the provider is deferred.&#xA;     *&#xA;     * @var bool&#xA;     */&#xA;    protected $defer = true;&#xA;&#xA;    /**&#xA;     * Register the service provider.&#xA;     *&#xA;     * @return void&#xA;     */&#xA;    public function register()&#xA;    {&#xA;        $this-&amp;gt;app-&amp;gt;singleton(&#39;command.email.send&#39;, function () {&#xA;            return new SendEmails;&#xA;        });&#xA;&#xA;        $this-&amp;gt;commands(&#39;command.email.send&#39;);&#xA;    }&#xA;&#xA;    /**&#xA;     * Get the services provided by the provider.&#xA;     *&#xA;     * @return array&#xA;     */&#xA;    public function provides()&#xA;    {&#xA;        return [&#39;command.email.send&#39;];&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在 &lt;code&gt;bootstrap/app.php&lt;/code&gt; 中注册服务提供者：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$app-&amp;gt;register(App\Providers\ SendEmailsServiceProvider::class);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;现在就大功告成，只需要执行 &lt;code&gt;php artisan email:send XXX&lt;/code&gt; 就可以使用自己编写的命令了。&lt;/p&gt;&#xA;</description>
      <author>TargetLiu</author>
      <pubDate>Fri, 22 Jul 2016 06:52:01 +0000</pubDate>
    </item>
    <item>
      <title>Lumen中使用速度更快的PhpRedis扩展（更新队列驱动）</title>
      <link>http://http://targetliu.com/2016/7/19/lumen-phpredis.html</link>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Lumen的确是一款适合做API，速度很快的框架。但是在项目中使用Redis时发现Lumen默认使用的 &lt;code&gt;predis/predis&lt;/code&gt; 会拖慢整体速度，特别是在高并发的情况下，所以寻思着使用 &lt;code&gt;PhpRedis&lt;/code&gt; 代替，毕竟 &lt;code&gt;PhpRedis&lt;/code&gt; 是C语言写的模块，性能上肯定优于 &lt;code&gt;predis&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;文中例子已经整理成一个 &lt;code&gt;composer&lt;/code&gt; 包，文末有简单介绍。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;phpredis-for-lumen-5&#34;&gt;PhpRedis for Lumen 5.*&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2016.7.29：v1.1.0发布，新增队列驱动，缓存驱动移动至 &lt;code&gt;TargetLiu\PHPRedis\Cache&lt;/code&gt; ，使用老版本的需要修改 &lt;code&gt;bootstrap/app.php&lt;/code&gt; 中缓存驱动加载位置。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;[TargetLiu/PHPRedis]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/TargetLiu/PHPRedis&#34;&gt;https://github.com/TargetLiu/PHPRedis&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://packagist.org/packages/targetliu/phpredis&#34;&gt;https://packagist.org/packages/targetliu/phpredis&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2 id=&#34;编译安装phpredis&#34;&gt;编译安装PhpRedis&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;由于 &lt;code&gt;PhpRedis&lt;/code&gt; 是C语言写的模块，需要编译安装。安装方法网上一搜一大把，请根据自己的环境选择相应的方法安装即可。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;两个可能用得上的链接：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://pecl.php.net/package/redis&#34;&gt;PECL - PhpRedis&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/phpredis/phpredis&#34;&gt;GitHub - PhpRedis&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;lumen中使用phpredis&#34;&gt;Lumen中使用PhpRedis&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;很简单，只需要在 &lt;code&gt;bootstrap/app.php&lt;/code&gt; 中添加下列代码将PhpRedis注入容器即可：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$app-&amp;gt;singleton(&#39;phpredis&#39;, function(){&#xA;    $redis = new Redis;&#xA;    $redis-&amp;gt;pconnect(&#39;127.0.0.1&#39;); //建立连接&#xA;        $redis-&amp;gt;select(1); //选择库&#xA;        $redis-&amp;gt;auth(&#39;xxxx&#39;); //认证&#xA;    return $redis;&#xA;});&#xA;unset($app-&amp;gt;availableBindings[&#39;redis&#39;]);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;绑定后即可通过 &lt;code&gt;app(&#39;phpredis&#39;)&lt;/code&gt; 直接使用 &lt;code&gt;PhpRedis&lt;/code&gt; 了，具体使用方法可以看相应的官方文档。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;lumen中为phpredis增加cache驱动&#34;&gt;Lumen中为PhpRedis增加Cache驱动&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;由于实际使用中更多的将Redis用于缓存，Lumen自带的Redis缓存驱动是基于 &lt;code&gt;predis/predis&lt;/code&gt; 实现，我们现在新建一个驱动以支持 &lt;code&gt;Phpredis&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;新增Cache驱动详细方法可以查看 &lt;a href=&#34;https://laravel.com/docs/5.2/cache#adding-custom-cache-drivers&#34;&gt;官方文档&lt;/a&gt;，这里指罗列一些关键的点。更多的内容也可以查看 &lt;a href=&#34;https://github.com/TargetLiu/PHPRedis&#34;&gt;TargetLiu/PHPRedis&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们首先创建一个 &lt;code&gt;ServiceProvider&lt;/code&gt; ：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;namespace App\Providers;&#xA;&#xA;use Illuminate\Support\Facades\Cache;&#xA;use Illuminate\Support\ServiceProvider;&#xA;use TargetLiu\PHPRedis\PHPRedisStore;&#xA;&#xA;class CacheServiceProvider extends ServiceProvider&#xA;{&#xA;    /**&#xA;     * Perform post-registration booting of services.&#xA;     *&#xA;     * @return void&#xA;     */&#xA;    public function boot()&#xA;    {&#xA;        Cache::extend(&#39;phpredis&#39;, function ($app) {&#xA;            return Cache::repository(new PHPRedisStore($app-&amp;gt;make(&#39;phpredis&#39;), $app-&amp;gt;config[&#39;cache.prefix&#39;]));&#xA;        });&#xA;    }&#xA;&#xA;    /**&#xA;     * Register bindings in the container.&#xA;     *&#xA;     * @return void&#xA;     */&#xA;    public function register()&#xA;    {&#xA;        //&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样就建立一个名为 &lt;code&gt;phpreids&lt;/code&gt; 的驱动。再创建一个基于 &lt;code&gt;Illuminate\Contracts\Cache\Store&lt;/code&gt; 契约的缓存操作类用以操作 &lt;code&gt;PhpRedis&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php&#xA;&#xA;namespace TargetLiu\PHPRedis;&#xA;&#xA;use Illuminate\Contracts\Cache\Store;&#xA;&#xA;class PHPRedisStore implements Store&#xA;{&#xA;&#xA;    /**&#xA;     * The Redis database connection.&#xA;     *&#xA;     * @var \Illuminate\Redis\Database&#xA;     */&#xA;    protected $redis;&#xA;&#xA;    /**&#xA;     * A string that should be prepended to keys.&#xA;     *&#xA;     * @var string&#xA;     */&#xA;    protected $prefix;&#xA;&#xA;    /**&#xA;     * Create a new Redis store.&#xA;     *&#xA;     * @param  \Illuminate\Redis\Database  $redis&#xA;     * @param  string  $prefix&#xA;     * @return void&#xA;     */&#xA;    public function __construct($redis, $prefix = &#39;&#39;)&#xA;    {&#xA;        $this-&amp;gt;redis = $redis;&#xA;        $this-&amp;gt;setPrefix($prefix);&#xA;    }&#xA;&#xA;    /**&#xA;     * Retrieve an item from the cache by key.&#xA;     *&#xA;     * @param  string|array  $key&#xA;     * @return mixed&#xA;     */&#xA;    public function get($key)&#xA;    {&#xA;        if (!is_null($value = $this-&amp;gt;connection()-&amp;gt;get($this-&amp;gt;prefix . $key))) {&#xA;            return is_numeric($value) ? $value : unserialize($value);&#xA;        }&#xA;    }&#xA;&#xA;    /**&#xA;     * Retrieve multiple items from the cache by key.&#xA;     *&#xA;     * Items not found in the cache will have a null value.&#xA;     *&#xA;     * @param  array  $keys&#xA;     * @return array&#xA;     */&#xA;    public function many(array $keys)&#xA;    {&#xA;        $return = [];&#xA;&#xA;        $prefixedKeys = array_map(function ($key) {&#xA;            return $this-&amp;gt;prefix . $key;&#xA;        }, $keys);&#xA;&#xA;        $values = $this-&amp;gt;connection()-&amp;gt;mGet($prefixedKeys);&#xA;&#xA;        foreach ($values as $index =&amp;gt; $value) {&#xA;            $return[$keys[$index]] = is_numeric($value) ? $value : unserialize($value);&#xA;        }&#xA;&#xA;        return $return;&#xA;    }&#xA;&#xA;    /**&#xA;     * Store an item in the cache for a given number of minutes.&#xA;     *&#xA;     * @param  string  $key&#xA;     * @param  mixed   $value&#xA;     * @param  int     $minutes&#xA;     * @return void&#xA;     */&#xA;    public function put($key, $value, $minutes)&#xA;    {&#xA;        $value = is_numeric($value) ? $value : serialize($value);&#xA;&#xA;        $this-&amp;gt;connection()-&amp;gt;set($this-&amp;gt;prefix . $key, $value, (int) max(1, $minutes * 60));&#xA;    }&#xA;&#xA;    /**&#xA;     * Store multiple items in the cache for a given number of minutes.&#xA;     *&#xA;     * @param  array  $values&#xA;     * @param  int  $minutes&#xA;     * @return void&#xA;     */&#xA;    public function putMany(array $values, $minutes)&#xA;    {&#xA;        foreach ($values as $key =&amp;gt; $value) {&#xA;            $this-&amp;gt;put($key, $value, $minutes);&#xA;        }&#xA;    }&#xA;&#xA;    /**&#xA;     * Increment the value of an item in the cache.&#xA;     *&#xA;     * @param  string  $key&#xA;     * @param  mixed   $value&#xA;     * @return int|bool&#xA;     */&#xA;    public function increment($key, $value = 1)&#xA;    {&#xA;        return $this-&amp;gt;connection()-&amp;gt;incrBy($this-&amp;gt;prefix . $key, $value);&#xA;    }&#xA;&#xA;    /**&#xA;     * Decrement the value of an item in the cache.&#xA;     *&#xA;     * @param  string  $key&#xA;     * @param  mixed   $value&#xA;     * @return int|bool&#xA;     */&#xA;    public function decrement($key, $value = 1)&#xA;    {&#xA;        return $this-&amp;gt;connection()-&amp;gt;decrBy($this-&amp;gt;prefix . $key, $value);&#xA;    }&#xA;&#xA;    /**&#xA;     * Store an item in the cache indefinitely.&#xA;     *&#xA;     * @param  string  $key&#xA;     * @param  mixed   $value&#xA;     * @return void&#xA;     */&#xA;    public function forever($key, $value)&#xA;    {&#xA;        $value = is_numeric($value) ? $value : serialize($value);&#xA;&#xA;        $this-&amp;gt;connection()-&amp;gt;set($this-&amp;gt;prefix . $key, $value);&#xA;    }&#xA;&#xA;    /**&#xA;     * Remove an item from the cache.&#xA;     *&#xA;     * @param  string  $key&#xA;     * @return bool&#xA;     */&#xA;    public function forget($key)&#xA;    {&#xA;        return (bool) $this-&amp;gt;connection()-&amp;gt;delete($this-&amp;gt;prefix . $key);&#xA;    }&#xA;&#xA;    /**&#xA;     * Remove all items from the cache.&#xA;     *&#xA;     * @return void&#xA;     */&#xA;    public function flush()&#xA;    {&#xA;        $this-&amp;gt;connection()-&amp;gt;flushDb();&#xA;    }&#xA;&#xA;    /**&#xA;     * Get the Redis connection instance.&#xA;     *&#xA;     * @return \Predis\ClientInterface&#xA;     */&#xA;    public function connection()&#xA;    {&#xA;        return $this-&amp;gt;redis;&#xA;    }&#xA;&#xA;    /**&#xA;     * Get the Redis database instance.&#xA;     *&#xA;     * @return \Illuminate\Redis\Database&#xA;     */&#xA;    public function getRedis()&#xA;    {&#xA;        return $this-&amp;gt;redis;&#xA;    }&#xA;&#xA;    /**&#xA;     * Get the cache key prefix.&#xA;     *&#xA;     * @return string&#xA;     */&#xA;    public function getPrefix()&#xA;    {&#xA;        return $this-&amp;gt;prefix;&#xA;    }&#xA;&#xA;    /**&#xA;     * Set the cache key prefix.&#xA;     *&#xA;     * @param  string  $prefix&#xA;     * @return void&#xA;     */&#xA;    public function setPrefix($prefix)&#xA;    {&#xA;        $this-&amp;gt;prefix = !empty($prefix) ? $prefix . &#39;:&#39; : &#39;&#39;;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过以上两个步骤基本上就完成了Cache驱动的创建，现在只需要在 &lt;code&gt;bootstrap/app.php&lt;/code&gt; 中注入新建的Cache驱动然后配置 &lt;code&gt;.env&lt;/code&gt; 中 &lt;code&gt;CACHE_DRIVER = phpredis&lt;/code&gt; ，最后再在 &lt;code&gt;config/cache.php&lt;/code&gt; 中加入相应的驱动代码即可&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&#39;phpredis&#39; =&amp;gt; [&#xA;    &#39;driver&#39; =&amp;gt; &#39;phpredis&#39;&#xA;],&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Cache的使用请查看Lumen&lt;a href=&#34;https://lumen.laravel.com/docs/5.2/cache&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;一个基于phpredis的lumen扩展包&#34;&gt;一个基于PhpRedis的Lumen扩展包&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;[TargetLiu/PHPRedis]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/TargetLiu/PHPRedis&#34;&gt;https://github.com/TargetLiu/PHPRedis&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://packagist.org/packages/targetliu/phpredis&#34;&gt;https://packagist.org/packages/targetliu/phpredis&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装：&lt;code&gt;composer require targetliu/phpredis&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装及使用方法请看 &lt;a href=&#34;https://github.com/TargetLiu/PHPRedis#phpredis-for-lumen-5&#34;&gt;README&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个包只是我做的一个简单示例，引入了 &lt;code&gt;PhpRedis&lt;/code&gt; 并做了最简单的缓存驱动。目前支持根据 &lt;code&gt;.env&lt;/code&gt; 获取Redis配置、Cache的基本读写等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Session和Queue可以继续使用Lumen自带的Redis驱动，两者互不影响。下一步如有需要可以继续完善这两部分的驱动。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个包将根据自己工作需求以及大家的已经进一步完善。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;欢迎大家提出意见共同完善。&lt;/p&gt;&#xA;</description>
      <author>TargetLiu</author>
      <pubDate>Tue, 19 Jul 2016 16:37:47 +0000</pubDate>
    </item>
    <item>
      <title>Lumen配置文件按需加载出现的坑</title>
      <link>http://http://targetliu.com/2016/7/18/lumen-configure.html</link>
      <description>&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;公司一个高并发API需要从Laravel移植到Lumen，由于数据库配置信息是通过远程或者缓存读取后动态配置，所以在中间件时使用到了 &lt;code&gt;Config::set&lt;/code&gt; 然而实际运行时发现数据库配置并没有更新。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;由于是从Laravel移植，因此保留了Facades的写法，Lumen中可以通过以下方法使用Facades:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;取消 &lt;code&gt;bootstarp/app.php&lt;/code&gt; 中 &lt;code&gt;$app-&amp;gt;withFacades();&lt;/code&gt; 的注释&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;use Illuminate\Support\Facades\XXX&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;另一方面，系统使用 &lt;code&gt;Redis&lt;/code&gt; 作为缓存，通过 &lt;code&gt;env&lt;/code&gt; 配置 &lt;code&gt;Redis&lt;/code&gt; ，配置信息存储在 &lt;code&gt;laravel/lumen-framework/config/database.php&lt;/code&gt; 在没有使用数据库先使用缓存的情况下，报没有传配置项的错误。&lt;/p&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;通过阅读源码 &lt;code&gt;laravel/lumen-framework/src/Application.php&lt;/code&gt; 发现，Lumen中的服务都是按需绑定并加载。先来看看 &lt;code&gt;make()&lt;/code&gt; 的代码：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function make($abstract, array $parameters = [])&#xA;{&#xA;    $abstract = $this-&amp;gt;getAlias($this-&amp;gt;normalize($abstract));&#xA;&#xA;    if (array_key_exists($abstract, $this-&amp;gt;availableBindings) &amp;amp;&amp;amp;&#xA;        ! array_key_exists($this-&amp;gt;availableBindings[$abstract], $this-&amp;gt;ranServiceBinders)) {&#xA;        $this-&amp;gt;{$method = $this-&amp;gt;availableBindings[$abstract]}();&#xA;&#xA;        $this-&amp;gt;ranServiceBinders[$method] = true;&#xA;    }&#xA;&#xA;    return parent::make($abstract, $parameters);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Lumen通过数组 &lt;code&gt;$availableBindings&lt;/code&gt; 实现了基本服务的按需绑定并加载。在服务按需绑定并加载的时候，使用了类似组件的形式通过 &lt;code&gt;loadComponent()&lt;/code&gt; 载入配置项并绑定服务。再来看看 &lt;code&gt;loadComponent()&lt;/code&gt; 的代码：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function loadComponent($config, $providers, $return = null)&#xA;{&#xA;    $this-&amp;gt;configure($config);&#xA;&#xA;    foreach ((array) $providers as $provider) {&#xA;        $this-&amp;gt;register($provider);&#xA;    }&#xA;&#xA;    return $this-&amp;gt;make($return ?: $config);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如此就释然为什么在中间件以及使用 &lt;code&gt;DB&lt;/code&gt; 之前想要动态配置数据库的信息时无法正确的写入配置项了。因为在这个时候 &lt;code&gt;DB&lt;/code&gt; 的相关配置文件还没有被载入。你先写入了配置项当使用 &lt;code&gt;DB&lt;/code&gt; 的时候会再次载入配置文件中的配置项覆盖动态写入的内容。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同理，使用 &lt;code&gt;Redis&lt;/code&gt; 时，由于 &lt;code&gt;Redis&lt;/code&gt; 相关配置是写在 &lt;code&gt;database.php&lt;/code&gt; 里的，仅仅通过 &lt;code&gt;$app-&amp;gt;register(Illuminate\Redis\RedisServiceProvider::class);&lt;/code&gt; 注册是无法获取到配置项，如果在使用 &lt;code&gt;Redis&lt;/code&gt; 时之前没有使用 &lt;code&gt;DB&lt;/code&gt; 就会报没有传配置项的错误。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;既然找到了问题所在，要解决起来也是很方便的。只要在修改、使用配置项之前先载入配置文件就可以解决这些问题。比如:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;app()-&amp;gt;configure(&#39;database&#39;);&lt;/code&gt; 载入所需要的配置文件&lt;/li&gt;&#xA;&lt;li&gt;在注册绑定服务到服务容器的时候使用 &lt;code&gt;loadComponent&lt;/code&gt; 进行注册绑定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
      <author>TargetLiu</author>
      <pubDate>Mon, 18 Jul 2016 15:48:28 +0000</pubDate>
    </item>
  </channel>
</rss>